- O conceito central do projeto é a arquitetura de microsserviços:
	1. Unity (C#) (Interface 3D)
	2. Python (Backend)
	3. FastAPI (Servidor)
	  - Tudo isso se conecta através de APIs (HTTP ou WebSocket)
- Principais coisas do projeto:
	- Gêmeo digital: Vai ser em tempo real (WebSocket), vai usar o MQTT (ideal para o IoT)
	
		Lâmpada <-> MQTT <-> FastAPI <-> WebSocket <-> Unity

	- LLM:
		- Vai usar HTTP (GET/POST), o Unity vai enviar uma pergunta (request) e o servidor processa e envia a resposta (response), não precisa de algo em tempo real
		- RAG: Tem como usar PDFs sobre o Inatel e sobre o XGmobile  e usa uma biblioteca (vector store)
			Unity <-> HTTP <-> FastAPI <-> LangChain (RAG) <-> Vector Store
- Extras: PostgreSQL para guardar informações, SQLModel (SQLAlchemy + Pydantic) para garantir que os JSON estão corretos e CORS para que haja a comunicação entre domínios diferentes e o docker pra amarrar tudo

```
Frontend -> Servidor -> Backend -> Servidor -> Frontend
```

- Fluxo HTTP/LLM:
	- O que acontece quando um usuário clicar para perguntar algo para o LLM?
		- **Papel do Frontend:** O usuário clica no botão -> O C# no Unity constrói uma requisição HTTP -> Essa requisição é enviada. O método será o POST, o url será um endpoint da API (ex: http://servidor.com/api/llm/perguntar) e o corpo será um JSON (ex: {"pergunta": "O que é o XGmobile?"})
		- **Papel do Servidor:** Vai receber a requisição POST no endpoint /api/llm/perguntar, o FastAPI lê o JSON e com o Pydantic valida esse JSON e o converte para o Python
		- **Papel do backend:** O FastAPI chama a função no Python correspondente, no caso de uma pergunta ao LLM chamaria a função do RAG. Fluxo da função no Python:
			- Langchain pega a pergunta -> Consulta o Vector Store (FAISS) em busca de chunks de textos relevantes dos PDFs -> O LangChain atualiza o prompt do LLM, melhorando o contexto -> O LLM gera a resposta usando os documentos
		- **Servidor (FastAPI):** O backend vai retornar uma resposta para o servidor, o FastAPI pega essa resposta e a converte para um JSON e a envia para o Unity 
		- **Frontend:** O C# (UnityWebRequest) recebe a resposta HTTP, lê o JSON da resposta e a converte para um C# e mostra a resposta no metaverso

- Fluxo WebSocket/Gêmeo digital:
	- Fluxo de dados do mundo real para o metaverso:
		- Dispositivo físico (um sensor por exemplo)
		- Protocolo MQTT: O sensor publica (publishes) uma mensagem MQTT no Broker MQTT (paho.mqtt.client) 
		- Callback: Assim que a menagem chega ao Broker, a função de callback no código Python é acionada 
		- FastAPI(WebSocket): Dentro da função de callback o servidor:
			- Obtém dados da mensagem 
			- Envia (faz um push) atualiza os dados em todos os clientes que estão conectados naquele momento
		- Frontend: O script C# mantém uma conexão WebSocket ligada e recebe os dados sem precisar fazer um request e atualiza o estado do gêmeo digital no metaverso
	