##### 1. Importações
Para criar o servidor, é preciso importar as classes base da biblioteca `http.server`:
- `HTTPServer`: A classe que gerencia o servidor em si
- `BaseHTTPRequestHandler`: A classe base para processar as requisições.

 ##### 2. O Handler de Requisições
É obrigatório criar um handler para lidar com as requisições HTTP.
- A classe `BaseHTTPRequestHandler` fornece as funcionalidades básicas, porém ela, por si só, não sabe como lidar com os métodos HTTP específicos (como `GET`, `POST`, etc.)
- Por isso, precisamos criar uma subclasse (no exemplo, `SimpleHandler`) que herda de `BaseHTTPRequestHandler`
- Nessa subclasse, implementamos os métodos correspondentes às requisições que queremos tratar (ex: `do_GET`, `do_POST`)
##### 3. Implementando o `do_GET`
Dentro da subclasse `SimpleHandler`, o método `do_GET` define como o servidor responde a uma requisição `GET`
1. **Status da Resposta**
    - `self.send_response(200)`: Envia o código de status HTTP. `200` significa "OK"
2. **Cabeçalhos (Headers)**
    - É preciso definir o cabeçalho da resposta ou, no mínimo, avisar o navegador que os cabeçalhos terminaram
    - `self.send_header("Content-type", "text/html; charset=utf-8")`: Define o tipo de conteúdo da resposta como HTML, com codificação UTF-8(com acentos)
    - `self.send_header("teste", "abc")`: Exemplo de adição de um cabeçalho personalizado (`teste: abc`).
    - `self.end_headers()`: Avisa que o envio dos cabeçalhos da resposta terminou (Obrigatório)
3. **Corpo (Body) da Resposta**
    - `data = f"""...""".encode()`: Prepara o conteúdo (HTML) a ser enviado. O método `.encode()` é crucial, pois converte a string para _bytes_, que é o formato que o método `write` aceita.
    - `self.wfile.write(data)`: Escreve os bytes do HTML no corpo da resposta HTTP.
##### 4. Iniciando o Servidor
Fora da classe, na execução principal do script:
1. **Instanciação do Servidor**
    - `server = HTTPServer(('localhost', 8000), SimpleHandler)`
    - O `HTTPServer` recebe dois parâmetros:
        - Um endereço (tupla): `('localhost', 8000)`. `localhost` indica que o servidor rodará localmente, e `8000` é a porta (uma porta comum para desenvolvimento local).
        - O handler: `SimpleHandler`, a classe que criamos para lidar com as requisições.
2. **Execução Contínua**
    - `server.serve_forever()`: Inicia o servidor para que ele fique "ouvindo" as requisições indefinidamente. O servidor continuará rodando até ser interrompido manualmente (ex: `Ctrl+C`).
##### 5.Código com comentários
```python
#Importar HTTPServer e BaseHTTPRequestHandler da biblioteca http.server

from http.server import HTTPServer, BaseHTTPRequestHandler

  

#Tem que criar um handler que vai lidar com as requisições HTTP

#BaseHTTPRequestHandler é uma classe base que fornece funcionalidades básicas para lidar com requisições HTTP

#Porém ele não sabe lidar com os metodos HTTP (GET, POST, etc)

#Então precisamos criar uma subclasse que herda de BaseHTTPRequestHandler e implementar os metodos

class SimpleHandler(BaseHTTPRequestHandler):

def do_GET(self):

print ("Recebida uma requisição GET")

self.send_response(200) #200 é o código de status HTTP para "OK"

#Definir o cabeçalho da resposta (precisa definir o cabeçalho ou avisar o navegador que a resposta terminou())

self.send_header("teste", "abc") #Adiciona um cabeçalho personalizado chamado "teste" com valor "abc"

self.send_header("Content-type", "text/html; charset=utf-8") #Define o tipo de conteúdo da resposta como HTML com codificação UTF-8

self.end_headers() #Avisa o navegador que os cabeçalhos da resposta terminaram

data = f""""

<html>

<head>

<title>Servidor HTTP Simples</title>

</head>

<body>

<h1>Olá, mundo!</h1>

<p> Diretorio: {self.path} </p>

</body>

</html>

""".encode()#Encode converte a string para bytes, write apenas aceita bytes

self.wfile.write(data) #Vai imprimir o conteúdo HTML na resposta HTTP

  

#Definir uma variavel server = HTTPServer e passar dois parametros: o endereço e a porta

#O endereço 'localhost' é usado para indicar que o servidor está rodando localmente

#segundo argumento é handler para lidar com as requisições HTTP

server = HTTPServer(('localhost', 8000), SimpleHandler)

#portal 8000 é uma porta comum para desenvolvimento local

  

#rodar pra sempre o servidor pra ele ficar ouvindo as requisições

server.serve_forever() #enquanto não for interrompido manualmente, o servidor continuará rodando

```

- Ao usar um framework como o FastAPI esse código não é necessário porém é importante entender o que está por trás de tudo. Em FastAPI chamaríamos o get assim: 
``` Python
@app.get("/")
def root():
	return {"message": "Olá, mundo!"}
```
- O FastAPI faz o send_response(200) (mensagem de ok), o cabeçalho, a conversão para JSON e para bytes tudo por baixo dos panos, o que nos permite focar na lógica e não na construção em si 
- 